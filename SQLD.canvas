{
	"nodes":[
		{"id":"a8df9937f8925729","type":"group","x":-100,"y":920,"width":2645,"height":1180,"label":"관계와 조인의 이해"},
		{"id":"e079f97945c2980e","type":"group","x":-160,"y":-600,"width":1600,"height":1260,"label":"정규화"},
		{"id":"6fd6b591d5031fbc","type":"group","x":-1883,"y":-1458,"width":1643,"height":1101,"label":"본질식별자 VS 인조 식별자"},
		{"id":"4b83d174f9fbf5e0","type":"group","x":-2175,"y":1066,"width":1867,"height":894,"label":"트랜잭션"},
		{"id":"c32458983537c609","type":"group","x":-2120,"y":-220,"width":1460,"height":994,"label":"Null속성의 이해 "},
		{"id":"3c53d34a626c681c","type":"text","text":"###### 삽입이상\n테이블에 데이터를 삽입할 때 의도하지 않은 정보까지 삽입해야 하는 현상\n\n###### 갱신이상\n중복 저장되어 있는 데이터 중 하나만 갱신하고 다른 하나를 갱신하지 않을 때 나타나는 데이터의 불일치 현상\n###### 삭제이상\n테이블의 특정 데이터를 삭제할 때 의도하지 않은 정보까지 삭제되는 현상","x":820,"y":-334,"width":460,"height":380,"color":"3"},
		{"id":"6748e4234f38e28b","type":"text","text":"#### 이상현상(Abnormality)","x":820,"y":-474,"width":290,"height":60,"color":"2"},
		{"id":"5b7db525cc4b2bff","type":"text","text":"- **정규화를 하지 않아 발생하는 현상(삽입이상, 갱신이상, 삭제이상)**","x":820,"y":-414,"width":520,"height":80},
		{"id":"a41cc9ffa55e8269","type":"text","text":"### 정규화","x":-140,"y":-580,"width":140,"height":60,"color":"1"},
		{"id":"87931266ae1d0617","type":"text","text":"- 데이터베이스의 성능 향상을 위해 데이터 중복을 허용하고 조인을 줄이는 DB 성능 향상 방법\n-  시스템의 성능 향상, 개발 및 운영의 단순화를 위해 정규화된 데이터 모델을 중복 ,통합, 분리하는 데이터 모델링 기법\n- 조회 속도를 향상시키지만 , 데이터 모델의 유연성은 낮아짐\n\n**반정규화 수행케이스**\n1) 정규화에 충실하여 종속성, 활용성은 향상되지만 수행 속도가 느려지는 경우\n2) 다량의 범위를 자주 처리해야 하는 경우\n3) 특정 범위의 데이터만 자주 처리하는 경우\n4) 요약/집계 정보가 자주 요구되는 경우","x":820,"y":168,"width":520,"height":374},
		{"id":"fe4516f5ae142fcb","type":"text","text":"#### 제 3정규화 : 이행함수종속 제거\n- 제 2 정규화를 진행한 테이블에 대해 이행적 종속을 없애도록 테이블을 분리\n-  이행적 종속성이란? A-> B, B->C의 관계가 성립할 때 A->C가 성립되는 것을 말함\n- (A,B)와 (B,C)로 분리하는 것\n","x":-140,"y":192,"width":760,"height":140,"color":"3"},
		{"id":"675d01bbfeefa3b6","type":"text","text":"#### 제 4정규화 : 다치종속 제거\n- 여러 컬럼들이 하나의 컬럼을 종속시키는 경우 분해하여 다중값 종속성을 제거","x":-140,"y":442,"width":760,"height":100,"color":"3"},
		{"id":"03804601b47515cb","type":"text","text":"#### BCNF(Boyce-Codd Normal Form) : 결정자가 후보키가 아닌 것 제거\n- 모든 결정자가 후보키가 되도록 테이블을 분해하는 것(결정자가 후보키가 아닌 다른 컬럼에 종속되면 안됨)\n","x":-140,"y":332,"width":760,"height":110,"color":"3"},
		{"id":"d7e3b88797b5babf","type":"text","text":"#### 제 5정규화 : 조인 종속 제거\n- 조인에 의해서 종속성이 발생되는 경우 분해","x":-140,"y":542,"width":760,"height":100,"color":"3"},
		{"id":"cc576ee77dc1ebd4","type":"text","text":"#### 정규화의 단계: 도부이결다조\n","x":-140,"y":-174,"width":400,"height":60,"color":"2"},
		{"id":"8d71acfd207a7413","type":"text","text":"- 하나에 엔티티에 많은 속성을 넣게 되면, 해당 엔티티를 조회할 때마다 많은 양의 데이터가 조회될 것이므로 **최소한의 데이터만을 하나의 엔티티에 넣는 식으로 데이터를 분해하는 과정**\n- 데이터의 일관성, 최소한의 데이터 중복, 최대한의 데이터 유연성 위한 과정\n- 데이터의 **중복을 제거하고 데이터 모델의 독립성을 확보**\n- 데이터 **이상현상을 줄이기 위한** 데이터 베이스 설계 기법\n- 엔티티를 상세화하는 과정으로 **논리 데이터 모델링 수행 시점**에서 고려됨\n- 제 1정규화부터 제 5정규화까지 존재, 실질적으로 제 3정규화까지만 수행","x":-140,"y":-428,"width":936,"height":224},
		{"id":"69379121b843a26d","type":"text","text":"#### 제 2정규화 :부분함수 종속 제거\n-  제 1 정규화를 진행한 테이블에 대해 완전 함수 종속을 만들도록 테이블 분해\n-  완전 함수 종속이란,  기본키를 구성하는 모든 컬럼의 값이 다른 컬럼을 결정짓는 상태\n- 기본키의 부분 집합이 다른 컬럼과 1:1 대응 관계를 갖지 않는 상태를 의미\n- 즉, PK가 2개 이상일 때, 발생하며 PK의 일부와 종속되는 관계가 있다면 분리함.\n","x":-140,"y":16,"width":760,"height":176,"color":"3"},
		{"id":"da8ca7040e7afb4a","type":"file","file":"이미지/Pasted image 20250212174522.png","x":-1184,"y":-499,"width":767,"height":142},
		{"id":"7083d6c1b968b4b9","type":"file","file":"이미지/Pasted image 20250212174515.png","x":-1184,"y":-699,"width":140,"height":200},
		{"id":"a509b7abbde125e3","type":"text","text":"PK: 주문상세번호(인조식별자 생성)\n- 주문상세번호로 각 주문 이력을 구분하기 때문에 같은 주문의 같은 상품이력이 저장 될 수 있음\n- 주문 상세번호만이 주식별자이므로 나머지 정보들이 불필요하게 중복 저장될 위험 발생\n- 실제 업무와 상관없느 주문상세번호를 주식별자로 생성하면 쓸모없는 인덱스 발생","x":-1044,"y":-699,"width":627,"height":194,"color":"2"},
		{"id":"7a154b85c029972d","type":"text","text":"#### 정규화의 개념","x":-140,"y":-488,"width":230,"height":60,"color":"2"},
		{"id":"42de40943236578b","type":"text","text":"## 식별자 구분(대체 여부에 따른)\n","x":-1850,"y":-1438,"width":394,"height":78,"color":"1"},
		{"id":"07a640e05a7f8f75","type":"file","file":"이미지/Pasted image 20250212174500.png","x":-1229,"y":-860,"width":705,"height":125},
		{"id":"5e21377ee4db2016","type":"text","text":"PK: 주문번호 + 주문순번 설계 (주문순번이라는 컬럼을 생성)\n하나의 주문에 여러 상품에 대한 주문 결과 저장 가능 -> 주문순번으로 인해 구분함.","x":-1080,"y":-1010,"width":370,"height":150,"color":"2"},
		{"id":"a720e2ea50777523","type":"file","file":"이미지/Pasted image 20250212174428.png","x":-1184,"y":-1438,"width":189,"height":199},
		{"id":"53e08afd603492fd","type":"text","text":"PK: 주문번호 + 상품번호 설계 (본질 식별자)\n하나의 주문번호로 같은 상품의 주문 결과를 저장할수 없게 된다.","x":-1194,"y":-1239,"width":370,"height":99,"color":"2"},
		{"id":"4b2d52cdf80ee4d7","type":"text","text":"#### 본질 식별자\n - 업무에 의해 만들어진 식별자(꼭 필요한 식별자)\n \n ####  인조식별자\n - 인위적으로 만들어지는 식별자( 꼭 필요하지 않지만 관리의 편이성 등의 이유로 인위적으로 만들어지는 식별자)\n - 본질식별자가 복잡한 구성을 가질 때 인위적으로 생김\n - 주로 각 행을 구분하기 위한 기본키로 사용되며 자동으로 증가하는 일련 번호 같은 형태임\n##### 단점\n1. 중복 데이터 발생 가능성-> 데이터 품질 저하\n2. 불필요한 인덱스 생성 -> 저장 공간 낭비 및  DML 성능 저하","x":-1850,"y":-1360,"width":540,"height":500,"color":"2"},
		{"id":"45980d79324fb871","type":"file","file":"이미지/Pasted image 20250212174436.png","x":-1229,"y":-1059,"width":149,"height":199},
		{"id":"987a0a0b7d811cec","type":"text","text":"#### 존재에 의한 관계와 행위에 대한 관계로 분류\n**존재 관계**: 엔티티 간의 상태를 의미  / ex) 사원 엔티티는 부서 엔티티에 소속\n**행위관계 :** 엔티티 간의 어떤 행위가 있는 것을 의미 /ex) 주문은 고객이 주문할 때 발생\n","x":790,"y":1130,"width":640,"height":120,"color":"3"},
		{"id":"c497329252fb0925","type":"text","text":"#### 관계의 분류","x":790,"y":1070,"width":230,"height":60,"color":"2"},
		{"id":"c59aca836c3d1c16","type":"text","text":"\n- 자기 자신끼리 관계가 발생, 즉 , 하나의 엔티티 내의 인스턴스끼리 계층 구조를 가지는 경우를 말함\n- 계층 구조를 갖는 인스턴스끼리 연결하는 조인을 셀프조인이라 함(같은 테이블 여러번 조인)","x":-80,"y":1620,"width":700,"height":400},
		{"id":"7cb8aa498ec662b5","type":"text","text":"- 엔티티의 인스턴스 사이의 논리적인 연관성\n- 엔티티의 정의, 속성 정의, 관계 정의에 따라서도 다양하게 변할 수 있음\n-  관계를 맺는다는 의미는 부모의 식별자를 자식에 상속하고, 상속된 속성을 매핑키(조인키)로 활용 ,부모 자식을 연결함.\n","x":-80,"y":1100,"width":820,"height":342},
		{"id":"35c867c566bc9ec3","type":"file","file":"이미지/Pasted image 20250212011213.png","x":-20,"y":1260,"width":550,"height":182},
		{"id":"f28badfb79f05ccb","type":"file","file":"이미지/Pasted image 20250212171909.png","x":-947,"y":1183,"width":599,"height":494},
		{"id":"0616666d9de98883","type":"text","text":"#### ORDER BY 절 \n- 데이터는 입력된 순서대로 출력되나, **출력되는 행의 순서를 사용자가 변경하고자 할 때 ORDER BY절을 사용**\n- ORDER BY 뒤에 명시된 컬럼 순서대로 정렬 -> 1차 정렬, 2차 정렬 전달 가능 \n- 정렬 순서를 오름차순(ASC), 내림차순(DESC)으로 전달(생략시 오름차순 )\n- 유일하게 SELECT절에 정의한 컬럼 별칭 사용 가능 \n- SELECT절에 선언된 순서대로의 순자 전달 가능 (컬럼명과 숫자 혼합 사용가능 )\n\n### 복합 정렬\n- 먼저 정렬한 값의 동일한 결과가 있을 경우 추가적으로 정렬 가능 \n- 1차 정렬한 값이 같은 경우 그 값 안에서 2차 정렬 컬럼 값의 정렬이 일어남\n\n\n### NULL의 정렬 -> NULLS LAST가 기본\n- NULL을 포함한 값의 정렬 시 ORACLE은 기본적으로 NULL을 마지막에 배치 (SQL SEVER는 처음에 배치)\n- ORACLE은 ORDER BY절에 NULLS LAST | NULLS FIRST을 명시하여 NULL 정렬 순서 변경 가능\n","x":40,"y":3580,"width":700,"height":640},
		{"id":"1c8d723822dbe7a3","type":"text","text":"#### HAVING 절 \n- **그룹 함수 결과를 조건으로 사용할때 사용하는 절** \n- ```WHERE```  절을 사용하여 그룹을 제한 할수 없으므로 ```HAING```절에 전달\n- `HAVING` 절이 GROUP BY절 앞에 올수는 있지만 뒤에 쓰는 것을 권장\n- 내부적 연산 순서가 SELECT절보다 먼저이므로 SELECT절에서 선언된 Alias 사용불가\n","x":60,"y":3344,"width":700,"height":196},
		{"id":"37faab13a3b3b552","type":"text","text":"#### 조인(JOIN)\n- 여러 테이블의 데이터를 사용하여 동시 출력하거나 참조 할 경우 사용\n- FROM절에 조인할 테이블 나열\n- ORACLE 표준은 테이블 나열 순서 중요X, ANSI 표준은 OUTER JOIN 시 순서 중요\n- WHERE 절에서 조인 조건을 작성 (ORACLE 표준 )\n- 동일한 열 이름이 여러 테이블에 존재할 경우 열 이름 앞에 테이블 이름이나 Alias 붙임\n- N개의 테이블을 조인하려면 최소 N-1개의 조인 조건이 필요\n- ORACLE 표준과 ANSI 표준이 서로 다름\n\n\n### 조인 종류\n###### 조건의 형태에 따라\n1) EQUI JOIN(등가 JOIN) : JOIN 조건이 동등 조건인 경우 '='\n 같은 값을 가지는 행을 연결하여 결과를 얻는 조인 방법\n where절에 두 테이블의 공통 컬럼에 대한 조인 조건을 나열 \n\n2) NON JOIN(비등가 JOIN): JOIN조건이 동등 조건인 아닌 경우\n 테이블을 연결짓는 조인 컬럼에 대한 비교 조건이 '<', BETWEEN A AND B와 같이 '=' 조건이 아닌 연산자를 사용\n\n###### 조인 결과에 따라\n1) INNER JOIN :  JOIN 조건에 성립하는 데이터만 출력하는 경우\n2) OUTER JOIN: JOIN조건에 성립하지 않는 데이터도 출력하는 경우\n    (LEFT/RIGHT/FULL OUTER JOIN으로 나뉨)\n3) NATURAL JOIN: 조인조건 생략 시 두 테이블에 같은 이름으로 자연 연결되는 조인\n4) CROSS JOIN: 조인조건 생략 시 두 테이블의 발생 가능한 모든 행을 출력하는 조인\n5) SELF JOIN: 하나의 테이블을 두 번 이상 참조하여 연결하는 조인\n\n###### 세 테이블 이상의 조인\n- 관계를 잘 파악하여 모든 테이블이 연결되도록 조인 조건 명시\n- N개 테이블의 경우 최소 N-1개의 조인 조건 필요\n- 만약 필수 조인 조건이 하나라도 생략될 경우 카타시안 곱 발생\n\n#### SELF JOIN\n- 한 테이블 내 각 행끼리 관계를 갖는 사용하는 조인 기법\n- 한 테이블을 참조할 때마다(필요할 때마다 ) 명시해야 함\n- 테이블명이 중복되므로 반드시 테이블 별칭 사용\n\n\n\n### ANSI 표준\n##### INNER JOIN== 내부조인\n조인 조건이 일치한 행만 추출(ORACLE 조인 기본)\nFROM절에 INNER JOIN 혹은 줄여서 JOIN을 명시\nUSING이나 ON 조건절을 필수적으로 사용\n\n### On절\n- 조인할 양 컬럼의 컬럼명이 서로 다르더라도 사용가능\n- On 조건의 괄호는 옵셥(생략가능)\n- 컬럼명이 같을 경우 테이블 이름이나 별칭을 사용하여 명확하게 지정\n- 조인조건 명시, WHERE절에서는 일반조건 명시(WHERE절과 ON절을 쓰임에 따라 명확히 구분)\n\n#### USING 조건절\n- 조인할 컬럼명이 같을 경우 사용\n- Alias나 테이블 이름 같은 접두사 붙이기 불가\n- 괄호 필수 \n\n#### NATURAL JOIN\n- 두 테이블 간의 동일한 이름을 가지는 모든 컬럼들에 대해 EQUI JOIN을 수행\n- USING, ON , WHERE 절에서 조건 정의 불가\n- JOIN에 사용된 컬럼들은 데이터 유형이 동일해야 하며 접두사를 사용불가\n###### 주의사항\n- 동일한 이름의 모든 컬럼을 조인 컬럼으로 사용하므로 컬럼의 모든 값이 모두 같을 때만 결과가 리턴 됨\n- STUDENT 와 PROFERSSOR 테이블에는 NAME컬럼과 PROFNO컬럼이 컬럼명이 서로 동일함.\n","x":40,"y":4280,"width":700,"height":660},
		{"id":"07abd88c79cfdb88","type":"text","text":"#### 특성: ACID\n\n","x":-2155,"y":1370,"width":212,"height":60,"color":"2"},
		{"id":"70c8affaa2c13ced","type":"text","text":" - 두 엔티티의 관계가 서로 필수적일 때 하나의 트랜잭션을 형성 \n - 두 엔티티가 서로 독립적 수행이 가능하다면 선택적 관계로 표현\n\n##### IE 표기법)\n- 원을 사용하여 필수적 관계와 선택적 관계를 구분\n- 필수적 관계에는 원을 그리지 않는다.\n- 선택적 관계에는 관계선 끝에 원을 그린다.\n\n##### 바커 표기법) \n- 실선과 점선으로 구분\n- 필수적 관계는 관계선을 실선으로 표기\n- 선택적 관계는 관계선을 점선으로 표기","x":-1400,"y":1183,"width":453,"height":471},
		{"id":"df0cc9c039c1faec","type":"file","file":"이미지/Pasted image 20250212011846.png","x":1510,"y":1205,"width":400,"height":251},
		{"id":"b7641f2cb92e2f26","type":"text","text":"\n- 두 테이블 중 하나만 가능한 관계를 말함\n  ex) 주문 엔티티에는 개인 또는 법인번호 둘 중 하나만 상속될 수 있음 -> 상호배타적 관계\n 즉 , 주문은 개인 고객이거나 법인고객 둘 중 하나의 고객만이 가능\n","x":680,"y":1620,"width":700,"height":265},
		{"id":"7115d573e651aa45","type":"file","file":"이미지/Pasted image 20250212012405.png","x":730,"y":1753,"width":399,"height":120},
		{"id":"86d2d6c75db96508","type":"file","file":"이미지/Pasted image 20250212012206.png","x":-40,"y":1760,"width":399,"height":249},
		{"id":"1d3393e246337038","type":"text","text":"- Null을 포함한 연산 결과는 항상 NULL\n- 집계함수는 NULL을 제외한 연산 결과 리턴 ,SUM, AVG, MIN, MAX 등의 함수는 항상 NULL 을 무시한다\n","x":-2113,"y":80,"width":813,"height":684},
		{"id":"0df18c21b44cdea1","type":"file","file":"이미지/Pasted image 20250212173350.png","x":-2113,"y":192,"width":525,"height":178},
		{"id":"6150535cd776d09e","type":"text","text":"1) **원자성(Atomicity):** 하나의 트랜잭션으로 묶인 연산들은 \"All or Nothing\"의 개념으로 모두 실행되거나 전혀 실행되지않아야 함.\n2) **일관성(Consistency):** 이전에 DB에 오류가 없다면 트랜잭션 이후에도 오류가 없다. (정합성)\n3) **고립성(Isolation):** 독립적으로 수행되며 다른 트랜잭션이 실행 중간에 간섭하거나 영향을 미치지 않음\n4) **영속성(Durability)**: DB에 영구적으로 저장되어 유지됨.","x":-2155,"y":1430,"width":720,"height":194},
		{"id":"fa6e51436ee5ee76","type":"text","text":"#### 트랜잭션의 격리수준이 낮을때의 문제점\n\n","x":-2147,"y":1624,"width":427,"height":60,"color":"2"},
		{"id":"f27d5bbe512ab7a0","type":"text","text":"#### 트랜잭션\n","x":-2155,"y":1153,"width":227,"height":60,"color":"2"},
		{"id":"e9bce4613c0359a6","type":"text","text":"## 모델이 표현하는 트랜잭션의 이해\n","x":-2155,"y":1086,"width":415,"height":60,"color":"1"},
		{"id":"4d2fc718230334aa","type":"text","text":"- 하나의 연속적인 업무 단위\n- 트랜잭션에 의한 관계는 필수적인 관계 형태를 가짐\n- 하나의 트랜잭션에는 여러 SELECT, INSERT, DELETE, UPDATE  등이 포함될 수 있음\n- 모두 성공하거나 모두 취소되어야 함.\n- 부분 COMMIT 불가","x":-2155,"y":1213,"width":735,"height":147},
		{"id":"28082c891b7cfefc","type":"text","text":"#### 필수적, 선택적 관계와 ERD\n","x":-1400,"y":1123,"width":300,"height":60,"color":"2"},
		{"id":"ace867f7299f4896","type":"text","text":"### 서브쿼리 \n- 하나의 SQL 문안에 포함된 또 다른 SQL 문을 의미\n- 반드시 괄호로 묶어야 함\n\n**서브쿼리 사용 가능한 위치**\n1) SELECT 절\n2) FROM절\n3) WHERE절\n4) HAVING절\n5) ORDER BY절\n6) 기타 DML(INSERT,DELETE,UPDATE)절\n\n#### GROUP BY 절 사용불가\n\n\n### 서브쿼리 종류\n1. 동작하는 방식에 따라\n**UN-CORRELATED(비연관) 서브쿼리**\n- 서브쿼리에 메인쿼리(외부쿼리)테이블의 컬럼을 가지고 있지 않은 형태의 서브쿼리\n- 서브쿼리가 메인쿼리의 값을 참조하지 않고 독립적으로 실행함\n- 서브쿼리는 한 번만 실행됨.\n\n**CORRLEATED(연관) 서브쿼리**\n- 서브쿼리에 메인쿼리(외부쿼리) 테이블의 컬럼을 가지고 있는 형태의 서브쿼리\n- 서브쿼리가 메인쿼리의 컬럼을 참조하고 있기 때문에 서브쿼리의 실행이 메인쿼리와 독립적이지 않음\n- 메인 쿼리의 각 행에 대해 서브쿼리가 실행됨.\n\n1. 위치에 따라 \n a) **스칼라 서브쿼리** -> SELECT\n  - SELECT절에 사용하는 서브쿼리\n  - 서브쿼리 결과를 마치 하나의 컬럼처럼 사용하기 위해 주로 사용\nb) **인라인 뷰** ->FROM\n- FROM 절에 사용하는 서브쿼리\n- 서브 쿼리 결과를 테이블처럼 사용하기 위해 주로 사용\nc) **WHERE 절 서브쿼리**\n - 가장 일반적인 서브쿼리\n-  비교 상수 자리에 값을 전달하기 위한 목적으로 주로 사용(상수항의 대체)\n- 반환되는 데이터의 형태에 따라 단일행 서브쿼리, 다중행 서브쿼리, 다중컬럼, 서브쿼리, (상호)연관 서브쿼리로 구분\n\n\n","x":-3355,"y":4918,"width":595,"height":1402},
		{"id":"cc72d649ddc75726","type":"text","text":"#### 반정규화 =정규화를 하지않음","x":820,"y":108,"width":360,"height":60,"color":"2"},
		{"id":"98302720b094e028","type":"text","text":"#### 제 1정규화 : 원자값이 아닌 도메인 분해\n- 테이블의 컬럼이 원자성(한 속성이 하나의 값을 갖는 특성)을 갖도록 테이블을 분해하는 단계\n- 하나의 행과 컬럼의 값이 반드시 한 값만 입력되도록 행을 분리하는 단계\n","x":-140,"y":-114,"width":760,"height":130,"color":"3"},
		{"id":"efb9c586499c11df","type":"text","text":"1)  **Dirty Read :** 트랜잭션에 의해 수정되었으니 아직 커밋이 되지 않은 상태에서 다른 트랜잭션이 해당 데이터를 읽게 되면 발생하는 데이터의 불일치 현상\n2) **Non-Repeatable:** 한 트랜잭션 내에서 같은 쿼리를 두 번 실행할 때, 그 사이에 다른 트랜잭션이 값을 수정하거나 삭제하면서 첫 번째와 두 번쨰 쿼리의 실행 결과가 달라지는 현상\n3) **Phatom Read**: 한 트랜잭션 내에서 같은 쿼리를 두번 실행할 때, 그 사이에 다른 트랜잭션이 값을 삽입하면서 두 번째 쿼리에서 이전에 없던 레코드가 나타나는 현상.","x":-2147,"y":1684,"width":720,"height":194},
		{"id":"a1274c06a7968a43","type":"text","text":"#### 조인의 의미","x":1465,"y":1040,"width":230,"height":60,"color":"2"},
		{"id":"845d0c14fee5f57e","type":"text","text":"#### 관계의 개념","x":-80,"y":1040,"width":230,"height":60,"color":"2"},
		{"id":"7e88091081b0eaf4","type":"text","text":"### 관계와 조인의 이해","x":-80,"y":940,"width":280,"height":60,"color":"1"},
		{"id":"733ed34fb1c4b298","type":"text","text":"\n\n\n\n\n\n\n\n\n- 데이터의 중복을 피하기 위해 테이블은 정규화에 의해 분리됨. 두 테이블은 서로 관계를  맺게 되고 , 다시 이 두 테이블의 데이터를 동시에 출력하거나 관계가 있는 테이블을 참조하기 위해서는 데이터를 연결해야 하는데 이 과정을 조인이라고 함.","x":1465,"y":1100,"width":1060,"height":420},
		{"id":"2daa7aea046ec666","type":"text","text":"#### 계층형 데이터 모델","x":-80,"y":1560,"width":230,"height":60,"color":"2"},
		{"id":"da9954ecab219627","type":"text","text":"#### 상호배타적 관계","x":680,"y":1560,"width":230,"height":60,"color":"2"},
		{"id":"26ae16235cc17ade","type":"text","text":"- IE 표기법에서 NULL 허용 여부를 알수 없음\n- 바커 표기법에서는 속성 앞에 동그라미가 NULL 허용 속성을 의미함.![[Pasted image 20250212173608.png]]","x":-1260,"y":-140,"width":540,"height":820},
		{"id":"c6833dd64b37b71b","type":"text","text":"## NuLL의 ERD 표기법\n","x":-1260,"y":-200,"width":340,"height":60,"color":"1"},
		{"id":"6fda3442b0a3e247","type":"text","text":"## NuLL의 개념\n","x":-2100,"y":-200,"width":250,"height":60,"color":"1"},
		{"id":"e766d0293937d440","type":"text","text":"- 아직 입력된 값이 없는 상태 \n- 0과 빈문자열('')과는 다른 개념\n- 모델 설계 시 각 컬럼별로 NULL을 허용할 지를 결정(Nullalble column)","x":-2100,"y":-140,"width":540,"height":130},
		{"id":"7eff650d1544503c","type":"text","text":"## NuLL의 특성\n","x":-2100,"y":16,"width":250,"height":60,"color":"1"},
		{"id":"1676489052bc2916","type":"file","file":"이미지/Pasted image 20250212173410.png","x":-2113,"y":555,"width":526,"height":185},
		{"id":"f8c61acf5c0caaf4","type":"file","file":"이미지/Pasted image 20250212173403.png","x":-2113,"y":370,"width":526,"height":185}
	],
	"edges":[]
}