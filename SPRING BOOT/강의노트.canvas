{
	"nodes":[
		{"id":"ca5ac88dd06008e0","type":"group","x":-5360,"y":-2160,"width":5680,"height":10800,"label":"Section2"},
		{"id":"025acb816c28301b","type":"group","x":440,"y":-2160,"width":3720,"height":6640,"label":"Section3"},
		{"id":"54cdaa2563f9f8ac","type":"group","x":2904,"y":-2145,"width":1256,"height":2572,"label":"Service로직에 집중할수 있는 이유"},
		{"id":"6ee8c014bb583c90","type":"group","x":-1760,"y":-519,"width":780,"height":398,"label":"Spring"},
		{"id":"d8188052e9b477c0","type":"group","x":-3000,"y":-1200,"width":1117,"height":260,"label":"느슨한 결합 다이어그램"},
		{"id":"7c4a531516e68f66","type":"group","x":-1760,"y":-1039,"width":780,"height":360,"label":"JVM"},
		{"id":"873e26a8a3834446","type":"text","text":"### PostConstructor및 PreDestory\n\n```java\npackage com.in28minutes.learnspringframework.examples.f1;  \n  \nimport jakarta.annotation.PostConstruct;  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.stereotype.Component;  \n  \nimport java.util.Arrays;  \n  \n@Component  \nclass SomeClass {  \n    private SomeDependency someDependency;  \n  \n  public SomeClass(SomeDependency someDependency) {  \n      super();  \n      this.someDependency = someDependency;  \n      System.out.println(\"All dependencies are ready\");  \n  }  \n @PostConstruct  \n  public void initioalize() {  \n      someDependency.getReady();  \n  }  \n}  \n  \n@Component  \nclass SomeDependency {  \n  \n    public void getReady() {  \n        System.out.println(\"Some logic using SomeDependency\");  \n    }  \n}  \n  \n@Configuration  \n@ComponentScan  \npublic class PrePostAnnotationsContextLauncherApplication {  \n  \n    public static void main(String[] args) {  \n        try (var context=  \n                     new AnnotationConfigApplicationContext(PrePostAnnotationsContextLauncherApplication.class)){  \n            Arrays.stream(context.getBeanDefinitionNames())  \n                    .forEach(System.out::println);  \n        }  \n    }  \n}\n```\n\n- 모든 의존성이 준비되고 ,의존성이 준비된 후에는 초기화됩니다. Spring은 자동으로 의존성을 연결하고 의존성을 자동 연결하는 대로 `@PostConstruct`한 메서드를 호출함.\n### `@PostConstruct`-> 의존성 주입 완료된 후 실행 해야 되는 메서드에서 사용하며, 이 메서드는 클래스를 사용하기 전에 호출되어야 함. 다른 Bean이 이 Bean을 사용 할수 있게 메서드 호출됨.\n- DB 등에서 데이터를 가져오려는 경우 사용함.\n\n### `@PreDestory `-> 애플리케이션이 종료되기 전에 , 컨텍스트에서 Bean이 삭제되기전에 호출하는 어노테이션 \n -  자원 정리, 종료 작업, 리소스 해제 등을 처리할 때 사용됨.\n\n \n- ","x":8240,"y":6280,"width":1340,"height":1600},
		{"id":"b49749eabd2d8fc5","type":"text","text":"## Bean Scope->  Prototype & Singleton\n\n```java title=\"\"\npackage com.in28minutes.learnspringframework.examples.e1;  \n  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.context.annotation.Scope;  \n  \nimport java.util.Arrays;  \n  \n@Component\nclass NormalClass {  \n  \n}  \n@Scope(value= ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n@Component\nclass PrototypeClass {  \n  \n}  \n@Configuration  \n@ComponentScan  \npublic class BeanScopesLauncherApplication {  \n  \n     public static void main(String[] args) {  \n        try (var context =  \n                     new AnnotationConfigApplicationContext(BeanScopesLauncherApplication.class)) {  \n            Arrays.stream(context.getBeanDefinitionNames())  \n                    .forEach(System.out::println);  \n  \n            System.out.println(context.getBean(NormalClass.class));  \n            System.out.println(context.getBean(NormalClass.class));  \n  \n            System.out.println(context.getBean(PrototypeClass.class));  \n            System.out.println(context.getBean(PrototypeClass.class));  \n            System.out.println(context.getBean(PrototypeClass.class));  \n        }  \n    }  \n}\n```\n```\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor\norg.springframework.context.annotation.internalCommonAnnotationProcessor\norg.springframework.context.event.internalEventListenerProcessor\norg.springframework.context.event.internalEventListenerFactory\nbeanScopesLauncherApplication\nnormalClass\nprototypeClass\ncom.in28minutes.learnspringframework.examples.e1.NormalClass@2e222612\ncom.in28minutes.learnspringframework.examples.e1.NormalClass@2e222612\ncom.in28minutes.learnspringframework.examples.e1.PrototypeClass@61386958\ncom.in28minutes.learnspringframework.examples.e1.PrototypeClass@73ee04c8\ncom.in28minutes.learnspringframework.examples.e1.PrototypeClass@7671cb68\n```\n\n-  두가지 클래스를 생성했는데 `NormalClass` , `PrototypeClass`\n- `NormalClass`는 똑같은 `NormalClass@2e222612`를 생성하지만 `PrototypeClass`는 호출할때마다 다른 해시코드를 갖는 인스턴스를 생성한다.\n-   Spring에서는 생성되는 모든 Bean은 싱글톤입니다.(싱글톤이란 하나의 객체만 생성해서 공유하는것을 말함.)\n- 싱글톤은 Spring IoC컨테이너당 객체 인스턴스가 딱 하나 ,프로토타입은 여러개 일수도 있음.\n-  다른 객체를 사용하고 싶을때 Prototype을 사용하면 된다. (아래 예시처럼)\n```java\n@Scope(value= ConfigurableBeanFactory.SCOPE_PROTOTYPE)\n@Component\nclass PrototypeClass {  \n}  \n```\n\n\n#### *Spring에서 웹 환경에서만 적용되는 Scopes *\n\n\n###### Request :(`HttpServletRequest` per 하나의 HTTP 요청당 하나의 객체 인스턴스를 유지하는 범위\n###### Session : 각 사용자별 HTTP 세션마다 하나의 객체 인스턴스\n###### Applicaiton :  웹 애플리케이션을 실행되는 동안 하나의 객체만 유지됨.\n###### WebSocket: WebSocket세션마다 하나의 객체 인스턴스\n-----------------------------------\n#### *Java Singleton(GOF) VS Spring Singleton*\n\n- ==Spring Singleton== : Spring IoC컨테이너당 객체 인스턴스가 하나\n- ==Java Singleton:== JVM 하나당 객체 인스턴스가 하나\n\nJVM에 Spring IoC컨테이너를 하나만 실행한다면 Spring  Singleton과 Java Singleton은 같은 의미일수 있다.\n하지만 JVM에 Spring IoC컨테이너가 여러 개 실행한다면 ,  Java Spring은 달라집니다.\n보통 JVM에 Spring Ioc 여러 개 실행하지 않는다. 그러니 Java Singleton과 Spirng Singleton은 (99.9%)똑같다.\n\n--------------------------------------------\n#### Stateful(서버가 상태를 저장) VS Stateless(서버가 상태를 저장하지 않음.) \n- 사용자별로 독립적인 상태를 유지하려는 경우 `Prototype을` 사용(장바구니,세션 데이터, 사용자 설정)\n- 애플리케이션 전역에서 하나의 인스턴스 사용(공통된 리소스나 서비스 객체 )\n\n\n\n\n ","x":8240,"y":3640,"width":1340,"height":2220},
		{"id":"6f200b1df0f973b8","type":"text","text":"#### Spring\n","x":-1719,"y":-414,"width":717,"height":265,"color":"4"},
		{"id":"467036995c5ac718","type":"text","text":"contraGame","x":-1694,"y":-324,"width":152,"height":100,"color":"3"},
		{"id":"d640e2a416721c81","type":"text","text":"MarioGame","x":-1519,"y":-324,"width":159,"height":100,"color":"3"},
		{"id":"a74aa1f64cccddf8","type":"text","text":"gameRunner","x":-1322,"y":-324,"width":160,"height":100,"color":"1"},
		{"id":"1b6acccebfc1dee2","type":"text","text":"## Spring Container == Spring Context == IOC cotainer는 무엇인가?\n\n - Spring Bean과 수명 주기를 관리합니다.\n -  JVM 내부에는 설정한 모든 Bean을 관리하는 Spring Context가 있음.\n - Java Class를 만들고 Configuration을 만들면 IOC 컨테이너가 런타임 시스템을 만듭니다.\n\n###  Bean Factory == Spring Cotainer\n- 기본적인 IOC 컨테이너(빈생성 & 의존성 주입)\n### Application Context == Advanced Contatiner\n- 고급 기능이 추가된 컨테이너 , (국제화, 이벤트, AOP지원, 환경설정)\n- 즉 BeanFactory의 확장판이며, 일반적으로 많이 사용함.\n\n## Java Bean VS POJO VS Spring Bean\n\n\n #### POJO: Plain Old Java Object\n \n-  모든 Bean은 POJO, 일반적인 오래된 JAVA 객체\n\n#### Java Bean\n```java\nclass JavaBean implements Serializable{  //EJB\n public JavaBean(){ //기본생성자\n \n\t }\n\t private String text;\n\t private int number;\n\t\n\t //getters & Setters\n\t public String getText(){\n\t return text;\n\t }\n\t public String setText(String text){\n\t this.text = text;\n\t }\n\t public int getNumber(){\n\t return number;\n\t }\n\t  public int setNumber(int number){\n\t this.number = number;\n\t }\n\n\n}\n\n```\n- 3가지 매우 중요한 제한이 따름\n- 1.  기본생성자 필수 \n- 2. 멤버 변수는 `private`으로 선언, GETTER & SETTER 메서드 만들기\n- 3. `Serializable `을 구현해야함.\n\n\n### Spring Bean\n- Spring 에서 사용되는 IOC Container 혹은 Bean Factory 혹은 Application Context에서 관리되는 모든 객체들\n\n","x":-600,"y":-202,"width":840,"height":1460},
		{"id":"c09eba9b05e9734f","type":"text","text":"JVM 내부에서 Spring Context를 생성하고 'name'이 생성된 Bean을  이는 String 값이며 Spring framework가 관리하도록 할 것.\n##### 1번쨰 순서 : ``@Configuration`` 클래스 만들기\n```java\npackage com.in28minutes.learnspringframework;  \n  \nimport org.springframework.context.annotation.Configuration;  \n  \n@Configuration  \npublic class HelloWorldConfiguration {  \n  \n      \n  \n}\n\n```\n여기에서 Spring Bean을 정의할 수 있습니다. ->Spring Bean: Spring에서 관리하는 객체\n``@Configuration`` 에서 메서드를 정의하여 Spring Bean을 생성할 수 있음\n##### 2번쨰 순서 : ``AnnotationConfigApplication`` 클래스 만들기\n\n```java\npackage com.in28minutes.learnspringframework;  \n  \nimport com.in28minutes.learnspringframework.game.GameRunner;  \nimport com.in28minutes.learnspringframework.game.PacmanGame;  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \n  \npublic class App02HelloWorldSpring {  \n    public static void main(String[] args) {  \n  \n        //1: Lanch a Spring Context  \n  \n        var context =  \n                new AnnotationConfigApplicationContext(HelloWorldConfiguration.class);  \n          \n        //2: Configure the things that we want Spring to manage - @Configuration  \n  \n    }  \n}\n\n```\nJVM 내에 Spring Context를 만들려면 ``AnnotationConfigApplicationContext`를 만드는 데 Configuration 클래스를 사용함.\n\n```java\npackage com.in28minutes.learnspringframework;  \n  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \n  \n@Configuration  \npublic class HelloWorldConfiguration {  \n  \n    @Bean  \n    public String name() {  \n        return \"Ranga\";  \n    }  \n  \n}\n```\n\n``@Bean``을 사용해서 스프링이 관리하는 객체로 만든다. 정확하게는 스프링 컨테이너가 관리하는 객체\n\n```java\npackage com.in28minutes.learnspringframework;  \n  \nimport com.in28minutes.learnspringframework.game.GameRunner;  \nimport com.in28minutes.learnspringframework.game.PacmanGame;  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \n  \npublic class App02HelloWorldSpring {  \n    public static void main(String[] args) {  \n  \n        //1: Lanch a Spring Context  \n  \n        var context =  \n                new AnnotationConfigApplicationContext(HelloWorldConfiguration.class);  \n  \n        //2: Configure the things that we want Spring to manage - @Configuration  \n        System.out.println(context.getBean(\"name\"));  \n    }  \n}\n```\n해당 Bean이 제대로 스프링 컨테이너에 실렸는지 확인해보자.\n\n![[Pasted image 20250311225920.png]]\n\n\n\n```java\npackage com.in28minutes.learnspringframework;  \n  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \n  \n  \nrecord Person(String name, int age) {}  \n  \nrecord Address(String Country, String city) {}  \n  \n@Configuration  \npublic class HelloWorldConfiguration {  \n  \n    @Bean  \n    public String name() {  \n        return \"Ranga\";  \n    }  \n    @Bean  \n    public int age() {  \n        return 15;  \n    }  \n  \n    @Bean  \n    public Person person() {  \n        return new Person(\"Ravi\", 20);  \n    }  \n    @Bean(name= \"address2\")  \n    public Address address() {  \n        return new Address(\"Korea\", \"Seoul\");  \n    }  \n}\n\n```\n`@Bean(name= \"address2\")` 이코드처럼 Bean명을 수동으로 설정할수있지만 코드 생략시 자동으로 메서드명으로 Bean명이 설정됌\n\n```java\npackage com.in28minutes.learnspringframework;  \n  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \n  \npublic class App02HelloWorldSpring {  \n    public static void main(String[] args) {  \n  \n        //1: Lanch a Spring Context  \n  \n        var context =  \n                new AnnotationConfigApplicationContext(HelloWorldConfiguration.class);  \n  \n        //2: Configure the things that we want Spring to manage - @Configuration  \n        System.out.println(context.getBean(\"address2\"));  \n        System.out.println(context.getBean(Address.class));  \n    }  \n}\n```\n\n![[Pasted image 20250312175240.png]]\n`System.out.println(context.getBean(Address.class)); System.out.println(context.getBean(\"address2\")); `  출력결과가 똑같다는걸 볼수있다. \nSpring이 여러개의 Bean을 정의할수 있으며 Spring에서 관리하는 객체를 검색할 수 있는 다양한 접근 방식을 제공함 \n\n```java\npackage com.in28minutes.learnspringframework;  \n  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \n  \n  \nrecord Person(String name, int age, Address address) {}  \n  \nrecord Address(String Country, String city) {}  \n  \n@Configuration  \npublic class HelloWorldConfiguration {  \n  \n    @Bean  \n    public String name() {  \n        return \"Ranga\";  \n    }  \n    @Bean  \n    public int age() {  \n        return 15;  \n    }  \n    @Bean  \n    public Person person() {  \n        return new Person(\"Ravi\", 20,  new Address(\"Main Street\", \"Utrecht\"));  \n    }  \n    @Bean  \n    public Person person2MethodCall() {  \n        return new Person(name(), age(),address()); //name, age  \n    }  \n    @Bean(name= \"address2\")  \n    public Address address() {  \n        return new Address(\"Korea\", \"Seoul\");  \n    }  \n}\n```\n기존 Bean을 가지고 재활용할수 있다는것.\n\n\n\n\n","x":-1753,"y":270,"width":873,"height":4790},
		{"id":"b002e9feb44b89cc","type":"text","text":"## Spring에서 관리하는 Bean 모두 어떻게 나열하나요?\n\n- `context`을 사용해서 `context.getBeanDefinitionNames`를 사용하면 이 레지스트리에 정의된 모든 이름을 반환함.\n- 레지스트리에 정의된 Bean 개수를 반환하는 `getBeanDefinitionCount`  \n- Bean을 확인하려면 `getBeanDefinition`을 사용해 Bean의 이름을 매개 변수로 구문 분석가능\n\n\n###### 여러개의 일치하는 Bean을 사용할수 있으면 어떻게 될까?\n `@Primary`를 사용해서 우선순위를 제일 먼저 설정하면 오류발생하지 않음.\n```java\n@Bean(name= \"address2\")  \n@Primary  \npublic Address address() {  \n    return new Address(\"Korea\", \"Seoul\");  \n}\n```\n\n###### `@Qualifier`\n```java\n@Bean(name= \"address3\")  \n@Qualifier(\"address3qualifier\")  \npublic Address address3() {  \n    return new Address(\"Motinagar\", \"Hderabad\");  \n}\n@Bean  \npublic Person person5QualifierString(String name, int age, @Qualifier(\"address3qualifier\") Address address) {  //name ,  age, address2  \n    return new Person(name, age,address); //name, age  \n}\n\n```\n\t여러개의 빈이 있을 때  특정한 빈을 지정해서 사용하는 어노테이션 \n\n\n##### Spring은 객체를 관리하고 자동연결(Auto-wiring)을 수행함.\n\n```java\npackage com.in28minutes.learnspringframework;  \n  \nimport com.in28minutes.learnspringframework.game.GameRunner;  \nimport com.in28minutes.learnspringframework.game.GamingConsole;  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \n  \npublic class App03GamingSpringBeans {  \n    public static void main(String[] args) {  \n  \n  \n        try (var context=  \n                     new AnnotationConfigApplicationContext(GamingConfiguration.class)){  \n            context.getBean(GamingConsole.class).up();  \n            context.getBean(GameRunner.class).run();  \n        }  \n    }  \n}\n\n```\n\n```java\npackage com.in28minutes.learnspringframework;  \n  \nimport com.in28minutes.learnspringframework.game.GameRunner;  \nimport com.in28minutes.learnspringframework.game.GamingConsole;  \nimport com.in28minutes.learnspringframework.game.PacmanGame;  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \n  \n@Configuration  \npublic class GamingConfiguration {  \n  \n    @Bean  \n    public GamingConsole game() {  \n        var game = new PacmanGame();  \n        return game;  \n    }  \n  \n    @Bean  \n    public GameRunner gameRunner(GamingConsole game) {  \n        var gameRunner = new GameRunner(game);  \n        return gameRunner;  \n    }  \n}\n\n```\n","x":-600,"y":1258,"width":840,"height":2082},
		{"id":"b90b223208eb0df0","type":"text","text":"#### Spring\n","x":-1730,"y":5,"width":810,"height":265,"color":"4"},
		{"id":"17542814129d628c","type":"text","text":"gameRunner","x":-1531,"y":138,"width":160,"height":100,"color":"1"},
		{"id":"d6bd114f1c72fec5","type":"text","text":"name","x":-1713,"y":138,"width":159,"height":100,"color":"5"},
		{"id":"3eabe5358c3d6de1","type":"text","text":"### JVM\n","x":-1753,"y":-80,"width":833,"height":350,"color":"5"},
		{"id":"451903ad56648c48","type":"text","text":"### JVM\n","x":-1742,"y":-499,"width":740,"height":350,"color":"5"},
		{"id":"a873f12835f7df39","type":"text","text":"### JVM\n","x":-1741,"y":-1020,"width":620,"height":320,"color":"5"},
		{"id":"adf95fac15d86aaa","type":"text","text":"contraGame","x":-1694,"y":-860,"width":175,"height":116,"color":"3"},
		{"id":"a13708010d3ff287","type":"text","text":"MarioGame","x":-1497,"y":-860,"width":175,"height":116,"color":"3"},
		{"id":"c0a762bb45100c2d","type":"text","text":"gameRunner","x":-1301,"y":-860,"width":175,"height":113,"color":"1"},
		{"id":"5486e2d5aacb9370","type":"text","text":"GameRunner ","x":-2980,"y":-1074,"width":156,"height":50,"color":"6"},
		{"id":"1f0c16407231e61b","type":"text","text":"SuperContra ","x":-2736,"y":-1074,"width":156,"height":50,"color":"5"},
		{"id":"919325a29584adda","type":"text","text":"PacMan ","x":-2736,"y":-990,"width":156,"height":50,"color":"5"},
		{"id":"18dcc000a039855a","type":"text","text":"\n```java title:ApplicationBasicJava\npackage com.in28minutes.learnspringframework;  \n  \nimport com.in28minutes.learnspringframework.game.GameRunner;  \nimport com.in28minutes.learnspringframework.game.MarioGame;  \n  \npublic class AppGamingBasicJava {  \n    public static void main(String[] args) {  \n    // 둘 중 하나는 주석처리하고 실행해야됨.\n        var marioGame = new MarioGame();  \n        var gameRunner = new GameRunner(marioGame);  \n        gameRunner.run();  \n    }  \n}\n```\n\n```java title:GameRunner\npackage com.in28minutes.learnspringframework.game;  \n  \npublic class GameRunner {  \n    private GamingConsole game;  \n  \n    public GameRunner(GamingConsole game) {  \n        this.game = game;  \n    }  \n    public void run() {  \n        System.out.println(\"Running game:\" +game);  \n        game.up();  \n        game.down();  \n        game.left();  \n        game.right();  \n    }  \n}\n```\n\n\n```java title:MarioGame\npackage com.in28minutes.learnspringframework.game;  \n  \npublic class MarioGame implements GameConsole {  \n  \n    public void up() {  \n        System.out.println(\"Jump\");  \n    }  \n  \n    public void down() {  \n        System.out.println(\"Go into a hole\");  \n    }  \n    public void left() {  \n        System.out.println(\"Go back\");  \n    }  \n    public void right() {  \n        System.out.println(\"Accelerate\");  \n    }  \n}\n```\n\n\n```java title:SuperContraGame\npackage com.in28minutes.learnspringframework.game;  \n  \npublic class SuperContraGame implements GameConsole {  \n  \n    public void up() {  \n        System.out.println(\"up\");  \n    }  \n    public void down() {  \n        System.out.println(\"Sit down\");  \n    }  \n    public void left() {  \n        System.out.println(\"Go back\");  \n    }  \n    public void right() {  \n        System.out.println(\"Shoot a bullet\");  \n    }  \n}\n```\n\n\n```java title:GameConsole\npackage com.in28minutes.learnspringframework.game;  \n  \npublic interface GamingConsole {  \n    void up();  \n    void down();  \n    void left();  \n    void right();  \n}\n```\n","x":-3000,"y":-920,"width":590,"height":1870,"color":"4"},
		{"id":"72077cbea98dd49e","type":"text","text":"### 결합(Coupling)의 중요한 점은?\n-   무언가를 변경하는 데 얼마나 많은 작업이 관련하여 있는지에 대한 측정\n- 마리오 -> 슈퍼콘트라 게임을 실행하는데 클래스에서 얼마나 많은 변화가 있어야 하는지 결합을 측정하는 점.\n- 일상 생활에도 많은 결합이 발생\n\t차에  엔진을 결합할때 많은 결합이 발생 반면 바퀴는 느슨하게 결합이 되어있어 타이어 펑크시 쉽게 교체.\n\t노트북은 어디에나 휴대 할 수 있어 특정 공간에 강하게 결합되어 있지않음, 컴퓨터는 움직이기가 힘듬.\n- 훌륭한 소프트웨어에서 구축하는데 중요한것은 변화에 대응한것. 그래서 필요한 느슨한 결합을 사용해야 함.\n- 가능한 한 코드를 적게 변경하면서 기능을 변경할 수 있게 해야 함","x":-4640,"y":310,"width":1210,"height":260,"color":"2"},
		{"id":"4b19c6827537cce0","type":"text","text":"# Iteration 3: Loose Coupled Spring Level 1\n 느슨한 결합으로 만든 Mario, SuperContra, Pacman etc\n- Spring Beans\n- Spring framework will manage obejects and wiring\n\n ","x":-1724,"y":-1484,"width":665,"height":214,"color":"1"},
		{"id":"143c176de46326d7","type":"text","text":"# Iteration 4: Loose Coupled Spring Level 2\n 느슨한 결합으로 만든 Mario, SuperContra, Pacman etc\n- Spring Annotations\n- Spring framework will create, manage & auto wire objects\n\n ","x":-600,"y":-1484,"width":620,"height":180,"color":"1"},
		{"id":"b385c75e15cd5f9a","type":"text","text":"# Iteration 2: Loose Coupled Interfaces\n 느슨한 결합으로 만든 Mario, SuperContra, Pacman etc\n- GameRunner class\n- GamingConsole interface\n\t - Game classes:Mario, SuperContra, Pacman etc\n\n ","x":-3000,"y":-1470,"width":620,"height":200,"color":"1"},
		{"id":"8da2f39b6d9f7b3e","type":"text","text":"# Iteration 1: Tightly Coupled Java Code\n 강한 결합으로 만든 Mario, SuperContra, Pacman etc\n GameRunner Class\n Game Classes: Mario, SuperContra, Pacman etc","x":-4640,"y":-1450,"width":590,"height":200,"color":"1"},
		{"id":"9f9a68c9420f9e6d","type":"text","text":"## @Bean을 등록하는 방법 3가지\n\n##### 단독사용하는 경우\n```java\npackage com.in28minutes.learnspringframework;  \n  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \n  \n@Configuration  \npublic class HelloWorldConfiguration {  \n  \n    @Bean  \n    public String name() {  \n        return \"Ranga\";  \n    }  \n  \n}\n```\n\n##### @Bean + 파라미터 주입\n\n```java\n@Bean  \npublic Person person3Parameters(String name, int age, Address address3) {  //name ,  age, address2  \n    return new Person(name, age,address3); //name, age  \n}\n```\n\n#### @Bean + 메서드 호출 \n```java\n@Bean  \npublic Person person2MethodCall() {  \n    return new Person(name(), age(),address()); //name, age  \n}\n```","x":-600,"y":-1292,"width":840,"height":1090},
		{"id":"e84b098e90a5cd63","type":"text","text":"객체는 Java Virtual Machine에서 생성되며 이러한 객체를 생성하고 결합하는 코드는 우리가 작성합니다.\n하지만 스프링 프레임워크가  이 모든 것을 관리하도록 하는 상태를 만들고자 합니다.\n우리 대신 객체를 생성하고 결합하도록 하겠음.","x":-1724,"y":-1270,"width":665,"height":161},
		{"id":"4a0a8086f35e68a8","type":"text","text":"\n#### ApplicationBasicJava\n```java\npackage com.in28minutes.learnspringframework;  \n  \nimport com.in28minutes.learnspringframework.game.GameRunner;  \nimport com.in28minutes.learnspringframework.game.MarioGame;  \n  \npublic class AppGamingBasicJava {  \n    public static void main(String[] args) {  \n  \n        var marioGame = new MarioGame();  \n        var gameRunner = new GameRunner(marioGame);  \n        gameRunner.run();  \n  \n    }  \n}\n```\n\n##### GameRunner\n```java\npackage com.in28minutes.learnspringframework.game;  \n  \npublic class GameRunner {  \n    private MarioGame game;  \n  \n    public GameRunner(MarioGame game) {  \n        this.game = game;  \n    }  \n  \n  public void run() {  \n    System.out.println(\"Running game:\" +game);  \n    game.up();  \n    game.down();  \n    game.left();  \n    game.right();  \n\t}\n}\n```\n\n#### MarioGame\n\n```java\npackage com.in28minutes.learnspringframework.game;  \n  \npublic class MarioGame {  \n  \n    public void up() {  \n        System.out.println(\"Jump\");  \n    }  \n  \n    public void down() {  \n        System.out.println(\"Go into a hole\");  \n    }  \n    public void left() {  \n        System.out.println(\"Go back\");  \n    }  \n    public void right() {  \n        System.out.println(\"Accelerate\");  \n    }  \n}\n```","x":-4640,"y":-1250,"width":590,"height":1560,"color":"4"},
		{"id":"d4c707bf7cb9ba88","type":"text","text":"\n#### ApplicationBasicJava\n```java\npackage com.in28minutes.learnspringframework;  \n  \nimport com.in28minutes.learnspringframework.game.GameRunner;  \nimport com.in28minutes.learnspringframework.game.MarioGame;  \n  \npublic class AppGamingBasicJava {  \n    public static void main(String[] args) {  \n    \n       var superContraGame = new SuperContraGame;\n        var gameRunner = new GameRunner(superContraGame);  \n        gameRunner.run();  \n    }  \n}\n```\n\n##### GameRunner\n```java\npackage com.in28minutes.learnspringframework.game;  \n  \npublic class GameRunner {  \n\t private SuperContraGame game;  \n  \n\tpublic GameRunner(SuperContraGame game) {  \n    this.game = game;  \n\t}\n  \n  public void run() {  \n    System.out.println(\"Running game:\" +game);  \n    game.up();  \n    game.down();  \n    game.left();  \n    game.right();  \n\t}\n}\n```\n\n#### SuperContraGame\n\n```java\npackage com.in28minutes.learnspringframework.game;  \n  \npublic class SuperContraGame {  \n  \n    public void up() {  \n        System.out.println(\"up\");  \n    }  \n    public void down() {  \n        System.out.println(\"Sit down\");  \n    }  \n    public void left() {  \n        System.out.println(\"Go back\");  \n    }  \n    public void right() {  \n        System.out.println(\"Shoot a bullet\");  \n    }  \n}\n```","x":-3910,"y":-1250,"width":620,"height":1560,"color":"4"},
		{"id":"a6ef766c4a1acf4e","type":"text","text":"Mario ","x":-2066,"y":-1160,"width":163,"height":51,"color":"5"},
		{"id":"09e49ac2501fd153","type":"text","text":"Mario ","x":-2736,"y":-1157,"width":156,"height":50,"color":"5"},
		{"id":"bdde4b5441baaa04","type":"text","text":"GameRunner ","x":-2503,"y":-1075,"width":163,"height":51,"color":"6"},
		{"id":"b7534024c246fc0d","type":"text","text":"GameConsole","x":-2300,"y":-1075,"width":183,"height":51,"color":"4"},
		{"id":"0753611c70d43d75","type":"text","text":"SuperContra ","x":-2066,"y":-1075,"width":163,"height":51,"color":"5"},
		{"id":"cc15d7924418e992","type":"text","text":"PacMan ","x":-2066,"y":-991,"width":163,"height":51,"color":"5"},
		{"id":"d786416485eb2d8f","type":"text","text":"# Section 2 ","x":-5340,"y":-1580,"width":620,"height":60},
		{"id":"373118e29d9ff113","type":"text","text":"# JAVA SPRING FRAMEWORK 목적\n##### 아래 포인트들을 하나씩 알아볼 예정\n  - 강한 결합 , 느슨한 결합\n -  IOC 컨테이너 (IOC Cotainer) Inversion Of Conver\n - Application Context\n - Component Scan\n - DI (Dependency Injection)\n - Spring Bean\n - Auto Wiring ","x":-5340,"y":-1520,"width":620,"height":340},
		{"id":"100dcbf9dadc5ce6","type":"text","text":"## 자동으로 Bean 생성하기 \n\n##### App03GamingSpringBeans클래스에 몰아서 실행보기.\n\n```java\n\npackage com.in28minutes.learnspringframework;  \n  \nimport com.in28minutes.learnspringframework.game.GameRunner;  \nimport com.in28minutes.learnspringframework.game.GamingConsole;  \nimport com.in28minutes.learnspringframework.game.PacmanGame;  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \n  \npublic class App03GamingSpringBeans {  \n    public static void main(String[] args) {  \n        try (var context=  \n                     new AnnotationConfigApplicationContext(GamingConfiguration.class)){  \n            context.getBean(GamingConsole.class).up();  \n            context.getBean(GameRunner.class).run();  \n        }  \n    }  \n}  \n  \n@Configuration  \nclass GamingConfiguration {  \n    @Bean  \n    public GamingConsole game() {  \n        var game = new PacmanGame();  \n        return game;  \n    }  \n    @Bean  \n    public GameRunner gameRunner(GamingConsole game) {  \n        var gameRunner = new GameRunner(game);  \n        return gameRunner;  \n    }  \n}\n```\n##### @Configuration를 App03GamingSpringBeans클래스에 붙혀서 실행시켜보기.\n\n```java\npackage com.in28minutes.learnspringframework;  \n  \nimport com.in28minutes.learnspringframework.game.GameRunner;  \nimport com.in28minutes.learnspringframework.game.GamingConsole;  \nimport com.in28minutes.learnspringframework.game.PacmanGame;  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.Configuration;  \n  \n@Configuration  \npublic class App03GamingSpringBeans {  \n    @Bean  \n    public GamingConsole game() {  \n        var game = new PacmanGame();  \n        return game;  \n    }  \n    @Bean  \n    public GameRunner gameRunner(GamingConsole game) {  \n        var gameRunner = new GameRunner(game);  \n        return gameRunner;  \n    }  \n    public static void main(String[] args) {  \n        try (var context=  \n                     new AnnotationConfigApplicationContext(App03GamingSpringBeans.class)){  \n            context.getBean(GamingConsole.class).up();  \n            context.getBean(GameRunner.class).run();  \n        }  \n    }  \n}\n\n```\n지금까지 수동으로 Bean을 설정했는데 이제는 자동으로 Bean을 설정해보도록 해보자.\n### Spring한테 Bean을 생성시켜보기\n```java\npackage com.in28minutes.learnspringframework.game;  \n  \nimport org.springframework.stereotype.Component;  \n  \n@Component  \npublic class PacmanGame implements GamingConsole{  \n  \n    public void up() {  \n        System.out.println(\"up\");  \n    }  \n    public void down() {  \n        System.out.println(\"Down\");  \n    }  \n    public void left() {  \n        System.out.println(\"left\");  \n    }  \n    public void right() {  \n        System.out.println(\"right\");  \n    }  \n}\n\n```\n\n`@Component`-> Spring이 해당 클래스를 자동으로 감지(Auto-detection)해서 Bean으로 등록해주는 역할\n`@Service` ,`@Repository` , `@Controller` 같은 어노테이션은 `@Component`의 확장판\n\n==**사용방법**==  \n직접 `@Component(\"beanName\")` Bean이름으로 등록될수 있고 생략하는 경우 클래스의 첫글자를 소문자로 변환.\n\n#### 오류 발생: NoSuchBeanDefinitionException\n특정 패키지에서 PacmanGame을 검색해야 한다고 Spring Framework에게 알려줘야 함.\n`@ComponentScan` 을 입력하면 Spring이 특정 패키지를 스캔하여  `@Component` ,`@Service`,`@Repository` , `@Controller`등이 붙은 클래스를 찾아서 자동으로 빈으로 등록하도록 하는 역할.\nSpring Boot는 자동으로 적용이됨.\n\n==**언제 사용하는것인지?** ==\nSpring Boot가 아닐때 / 특정 패키지만 스캔하고 싶을때(같은 패키지가 아닌 경우)\n  \n```java\npackage com.in28minutes.learnspringframework;  \n  \nimport com.in28minutes.learnspringframework.game.GameRunner;  \nimport com.in28minutes.learnspringframework.game.GamingConsole;  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \nimport org.springframework.context.annotation.Bean;  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.context.annotation.Configuration;  \n  \n@Configuration  \n@ComponentScan(\"com.in28minutes.learnspringframework.game\")\npublic class App03GamingSpringBeans {  \n    @Bean  \n    public GameRunner gameRunner(GamingConsole game) {  \n        var gameRunner = new GameRunner(game);  \n        return gameRunner;  \n    }  \n    public static void main(String[] args) {  \n        try (var context=  \n                     new AnnotationConfigApplicationContext(App03GamingSpringBeans.class)){  \n            context.getBean(GamingConsole.class).up();  \n            context.getBean(GameRunner.class).run();  \n        }  \n    }  \n}\n\n```\n\n###  Bean 코드를 생략해도 실행이 가능한 이유?\n\n```java\npackage com.in28minutes.learnspringframework;  \n  \nimport com.in28minutes.learnspringframework.game.GameRunner;  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.context.annotation.Configuration;  \n  \n@Configuration  \n@ComponentScan  \npublic class App03GamingSpringBeans {  \n  \n    public static void main(String[] args) {  \n        try (var context=  \n                     new AnnotationConfigApplicationContext(App03GamingSpringBeans.class)){  \n            context.getBean(GameRunner.class).run();  \n        }  \n    }  \n}\n```\n### GameRunner 클래스에 @Component를 쓰면 빈으로 등록되기 때문에 실행가능.\n추가로 `@Component`가 있는 클래스만 auto-wire되기때문에 PacmanGame만 실행이 되지만 MarioGame도 @Component를 쓰면 NoUniqueBeanDefinitionException 발생하기 때문에 확실하게 구분할수 있는 `@Primary`를 사용해서 우선권을 주어지는 빈을 설정하거나 `@Qualifier` 를 사용해서 특정 빈을 사용할수 있도록 설정하기.\n\n```java\npackage com.in28minutes.learnspringframework.game;  \n  \nimport org.springframework.beans.factory.annotation.Qualifier;  \nimport org.springframework.stereotype.Component;  \n  \n@Component  \n@Qualifier(\"SuperContraGameQualifier\")  \npublic class SuperContraGame implements GamingConsole {  \n  \n    public void up() {  \n        System.out.println(\"up\");  \n    }  \n    public void down() {  \n        System.out.println(\"Sit down\");  \n    }  \n    public void left() {  \n        System.out.println(\"Go back\");  \n    }  \n    public void right() {  \n        System.out.println(\"Shoot a bullet\");  \n    }  \n}\n\n```\n\n```java\npackage com.in28minutes.learnspringframework.game;  \n  \nimport org.springframework.beans.factory.annotation.Qualifier;  \nimport org.springframework.stereotype.Component;  \n  \n@Component  \npublic class GameRunner {  \n    private GamingConsole game;  \n  \n    public GameRunner(@Qualifier(\"SuperContraGameQualifier\") GamingConsole game) {  \n        this.game = game;  \n    }  \n    public void run() {  \n        System.out.println(\"Running game:\" +game);  \n        game.up();  \n        game.down();  \n        game.left();  \n        game.right();  \n    }  \n}\n\n```\n\n#### 언제 `@Primary`를 쓰고 `@Qualifier`를 쓸까?\n\nComplexAlgorithm(`@Primary`)과 AnotherComplexAlgortihm(`@Qualifier`)의 관점에서 항상 생각해야된다.\n-  아무 알고리즘을 사용하면 되면 -> `@Autowired`\n-  특정 알고리즘을 사용해야 하는 경우-> `@Qualifier`\n- `@Qualifier`가 `@Primary`보다 더 높은 우선순위를 갖고 있다는 점\n- 의존성을 사용하는 클래스의 관점에서 항상 생각하기.\n\n\n\n\n\n\n\n\n\n","x":-691,"y":3400,"width":931,"height":5120},
		{"id":"179cba948cb9ed02","type":"text","text":" ### Jakarta의 발전\n \n -  이전에는 J2EE였고 중간에는 Jave EE였으며 현재는 Jakarta EE라고 불림\n - 초기 버전에서 엔터프라이즈 기능 대부분은 JDK, 자바 개발 Kit에 Java언어로 직접 구축되어 있음\n - J2EE -> Java2 Plateform enterprise  Edition \n - Java EE -> Java Plateform Enterprise Edition (Rebranding)\n - Jakarta EE (Oracle gave Java EE rights to the Eclipse Foundation)\n\n\n### Jakarta EE\n #### Jakarta Server Pages -> JSP\n - 웹 애플리케이션 만들때 사용\nJakarta Standard Tag Libray -> JSTL\n- 웹 페이지에 동적 정보를 나타내는 데 사용할 수 있는 태그 라이브러리\n","x":-1040,"y":9680,"width":919,"height":500},
		{"id":"f77a80b92788306b","type":"text","text":"### **DI(Dependency )**\n -  의존성 주입은 3가지 유형이 있음. Constructor 주입 , setter 주입 , Field 주입\n ```java\n package com.in28minutes.learnspringframework.examples.a1;  \n  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.context.annotation.Configuration;  \n  \nimport java.util.Arrays;  \n  \n@Configuration  \n@ComponentScan  \npublic class DepInjectionLauncherApplication {  \n  \n    public static void main(String[] args) {  \n        try (var context=  \n                     new AnnotationConfigApplicationContext(DepInjectionLauncherApplication.class)){  \n            Arrays.stream(context.getBeanDefinitionNames())  \n                    .forEach(System.out::println);  \n        }  \n    }  \n}\n```\n#### 실행시 Bean 출력되는데 Spring에 필수\n```\norg.springframework.context.annotation.internalConfigurationAnnotationProcessor\norg.springframework.context.annotation.internalAutowiredAnnotationProcessor\norg.springframework.context.annotation.internalCommonAnnotationProcessor\norg.springframework.context.event.internalEventListenerProcessor\norg.springframework.context.event.internalEventListenerFactory\ndepInjectionLauncherApplication //@Configuration이 있기때문에 빈으로 출력\n```\n###### 자동으로 연결이 되어있지 않다.(Auto-wired)\n```java\npackage com.in28minutes.learnspringframework.examples.a1;  \n  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.stereotype.Component;  \n  \nimport java.util.Arrays;  \n  \n@Component  \nclass YourBusinessClass{  \n Dependency1 dependency1;  \n Dependency2 dependency2;  \n \n    @Override  \n    public String toString() {  \n        return \"Using \" + dependency1 + \" and \" + dependency2;  \n    }  \n}  \n@Component  \nclass Dependency1 {  \n  \n}  \n@Component  \nclass Dependency2 {  \n  \n}  \n@Configuration  \n@ComponentScan  \npublic class DepInjectionLauncherApplication {  \n  \n    public static void main(String[] args) {  \n        try (var context=  \n                     new AnnotationConfigApplicationContext(DepInjectionLauncherApplication.class)){  \n            Arrays.stream(context.getBeanDefinitionNames())  \n                    .forEach(System.out::println);  \n  \n            System.out.println(context.getBean(YourBusinessClass.class));  \n        }  \n    }  \n}\n```\n``` (출력결과)\norg.springframework.context.event.internalEventListenerProcessor\norg.springframework.context.event.internalEventListenerFactory\ndepInjectionLauncherApplication\ndependency1\ndependency2\nyourBusinessClass\nUsing null and null\n```\n####  **==Field 주입==**\n```java\n@Component  \nclass YourBusinessClass{  \n    @Autowired  \n    Dependency1 dependency1;  \n  \n    @Autowired  \n    Dependency2 dependency2;  \n  \n    @Override  \n    public String toString() {  \n        return \"Using \" + dependency1 + \" and \" + dependency2;  \n    }  \n}\n```\n```\nUsing com.in28minutes.learnspringframework.examples.a1.Dependency1@4e7912d8 and com.in28minutes.learnspringframework.examples.a1.Dependency2@53976f5c\n```\n### **==Setter 주입==**\n```java\n@Component  \nclass YourBusinessClass{  \n  \n    Dependency1 dependency1;  \n    Dependency2 dependency2;  \n  \n    @Autowired  \n    public void setDependency1(Dependency1 dependency1) {  \n        System.out.println(\"Setter Injection- setDependency1\");  \n        this.dependency1 = dependency1;  \n    }  \n    @Autowired  \n    public void setDependency2(Dependency2 dependency2) {  \n        System.out.println(\"Setter Injection- setDependency2\");  \n        this.dependency2 = dependency2;  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return \"Using \" + dependency1 + \" and \" + dependency2;  \n    }  \n}\n```\n```\nSetter Injection- setDependency1\nSetter Injection- setDependency2\n```\n### **==Constructor 주입(@Autowired)를 없이도 사용가능-> 가장 추천==**\n```java\n@Component  \nclass YourBusinessClass{  \n  \n    Dependency1 dependency1;  \n    Dependency2 dependency2;  \n  \n    @Autowired  \n    public YourBusinessClass(Dependency1 dependency1, Dependency2 dependency2) {  \n        super();  \n        System.out.println(\"Constructor Injection- YourBusinessClass\");  \n        this.dependency1 = dependency1;  \n        this.dependency2 = dependency2;  \n    }  \n  \n    @Override  \n    public String toString() {  \n        return \"Using \" + dependency1 + \" and \" + dependency2;  \n    }  \n}  \n@Component  \nclass Dependency1 {  \n  \n}  \n@Component  \nclass Dependency2 {  \n  \n}\n\n\n```\n```\nConstructor Injection- YourBusinessClass\n```\n\n    - Spring은 Constructor주입을 가장 추천하는데 그 이유는 모든 초기화가 한 메소드에서 발생하기 때문이다.\n\t- 객체의 불변성유지 `final`키워드를 사용할수 있어 의존성이 변경되지 않도록 보장되고, setter 주입 방식과 달리 , 객체 생성 후 의존성이 변경될 위험이 없음\n\t- 의존성이 명확하게 보장됨. 객체 생성시 모든 필요한 의존성이 주입되므로 불완전한 상태에 존재할 가능성 제로, 다른 주입은 미처 주입되지 않은 상태  에서 메서드가 호출될 위험이 있음\n\t- 테스트 용이함\n\t- 순환 참조(Circular Dependency)방지 , 생성자 주입은 순환 참조를 감지하면 오류발생 ,나머지 주입은 런타임 시점까지 이를 감지하지 못할수 있음.\n\n\n\n\n\n\n\n\n\n\n\n\n","x":480,"y":-2108,"width":1460,"height":4180},
		{"id":"b30c2cfec1bb809e","type":"text","text":"# Spring Stereotype Annotations\n\n## Spring에서 ` @Component` 특수화된 형태\n\n#### `@Service`\n- 서비스 레이어에서 사용, 비즈니스 로직이 처리하는데 사용\n#### `@Repository`\n- Bean이 DB와 통신하는 경우 , 데이터를 저장하거나 검색하거나 조작하는 경우 \n####  `@Controller`\n- 웹 애플리케이션과 REST API에서 컨트롤러를 정의하는데 사용됨.\n### 어떤 걸 사용하는게 좋을까요?\n\n- 정답은 가장 구체적으로 적혀있는 어노테이션을 사용하는게 사용용도를 정확하게 알수 있다.\n- 나중에 AOP(관점 지향 프로그래밍)를 사용하여 어노테이션을 감지하고 부가적인 동작을 추가할수 있다.\n- 그리고 위에 구체적인 어노테이션이 아닌 경우에 `@Component`를 사용","x":5960,"y":8190,"width":1380,"height":640},
		{"id":"0002534ebc4623de","type":"text","text":"# Spring Modules:\n### Web:\n- Spring MVC\n### Web Reacitive\n- Spring WebFlux\n### Data Access\n- JDBC, JPA\n### Integration:\n- JMS\n### Testing:\n- Mock Objects, Spring MVC Test\n\n\n# 왜 Spring은 모듈로 나누어져 있을까요?\n- 한가지 이유는 유연성, 각각 애플리케이션마다 요구사항은 다르고 , 각 애플리케이션은 다양한 모듈을 사용합니다. Db와 통신하는 웹 애플리케이션을 만든다면 Spring MVC를 사용할수 있고 Spring JDBC를 사용할수 있고, Spring Core를 사용할 수도 있죠. 모든 기능을 사용해야되는 것도 아니기 떄문이다.\n\n# Spring Projects\n## Spring Security:\n- 웹 애플리케이션이나 REST API에 보안을 추가할때 씀, MICROSERVICE에 인증, 권한 부여을 추가하려는 경우 사용\n## Spring Data:\n- 여러 DB와 통합할 때는 Spring Data를 씀, 이전에는 관계형 DB를 많이 사용했는데 요즘은 NoSQL DB를 아주 많이 씀, 우 2가지 DB를 통합하여 사용할수있는 방법\n\n## Spring Integration:\n- 대부분의 애플리케이션은 다른 애플리케이션과 통신하기 때문에 이러한 애플리케이션에서 통합 관련\n## Spring Boot\n- 마이크로서비스를 아주 빠르게 빌드하기 위해 새로운 Spring 프로젝트\n\n## Spring Cloud\n- Spring 네이티브 애플리케이션을 빌드 할 때는 Spring 프로젝트\n\n\n# Spring이 인기있는 이유?\n\n- 느슨한 결합(Loose Coupling) : 유지보수가 가능한 애플리케이션을 아주 쉽게 만들수 있다.\n- 단위테스트(Unit test) 가능함.\n- 비즈니스 로직에 집중할수 있다.(Boilerplate Code란? 반복적으로 사용되는 기본 코드를 템플릿을 의미함.)\n- 아키텍처 유연성이 높음: 여러개의 Spring 프로젝트와 모듈로 구성되어있기 때문에.\n- 계속 새로운 환경이 개발되고 있기때문","x":5960,"y":8830,"width":1380,"height":1560},
		{"id":"9390337a3e158114","type":"text","text":"### Resources에서 contextConfiguration.xml 파일 만들기\n``` xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>  \n<beans xmlns=\"http://www.springframework.org/schema/beans\"  \n       xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"  \n       xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\">  \n  \n  \n      \n  \n</beans>\n\n```\n- Bean을 정의할수 있음.\n\n```java\npackage com.in28minutes.learnspringframework.examples.h1;  \n  \nimport org.springframework.context.support.ClassPathXmlApplicationContext;  \n  \nimport java.util.Arrays;  \n  \npublic class XmlConfigurationContextLauncherApplication {  \n  \n    public static void main(String[] args) {  \n        try (var context=  \n                new ClassPathXmlApplicationContext(\"contextConfiguration.xml\")) {  \n            Arrays.stream(context.getBeanDefinitionNames())  \n                    .forEach(System.out::println);  \n        }  \n    }  \n}\n\n```\n\n## Annotation VS XML Configuration\n\n\nXML은 Bean 인스턴스를 만들려면 패키지 이름을 포함해 클래스 전체 이름을 나타내는 불편함이 있다.\n 특정한 구문을 따라야 하고 자동연결과 같은 걸 수행하려면 꽤 복잡한 구문을 사용해야 합니다.\n\nAnnotation은 짧고 간결한 반면, XML 설정은 아주 번거로움.\n\nXML설정은 사용한다면 POJO가 아주 깔끔해집니다.\nXML설정에는 자바코드를 안바꿔도 됩니다.\n하지만 Annotation은 관리하기 훨씬 쉽다. 소스 코드를 바꿀떄마다 어노테이션을 쉽게 업데이트 할수 있다.\n\n\n\nSpring 에서는 어노테이션은 자주 사용하지만 XML은 요즘 거의 사용되지 않습니다.\n전체 프로젝트에 일관적으로 사용하는게 좋다.\n일반적으로 .Java설정과 어노테이션 사용시에는 디버그 하기 어렵다. 그렇기 때문에 Spring Framework가 어떻게 작동하는 잘알아야 합니다. XML 설정은 너무 장\n\n\n\n","x":4200,"y":4720,"width":919,"height":1260},
		{"id":"e0a8a93c24131e3a","type":"text","text":"#### Lazy Initialization of Spring Beans : \n- Spring Bean의 기본 초기화는 즉시 초기화 (**Eager**)\n```java title:\"LazyInitializationLauncherApplication\"\npackage com.in28minutes.learnspringframework.examples.d1.a0;  \n  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.stereotype.Component;  \n  \n  \n@Component  \nclass ClassA {  \n  \n}  \n  \n@Component  \n//@Lazy  \nclass ClassB {  \n\n    private ClassA classA;  \n  \npublic ClassB(ClassA classA) {  \n    //Logic  \n    System.out.println(\"Some Initialization logic\");  \n    this.classA = classA;  \n\t}  \n}  \n@Configuration  \n@ComponentScan  \npublic class LazyInitializationLauncherApplication {  \n  \n    public static void main(String[] args) {  \n\t\t        try (var context= new AnnotationConfigApplicationContext(LazyInitializationLauncherApplication.class)){  \n        }    }  \n}\n```\n```\nSome Initialization logic\n```\n\n```java\npackage com.in28minutes.learnspringframework.examples.d1.a0;  \n  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.context.annotation.Lazy;  \nimport org.springframework.stereotype.Component;  \n  \n  \n@Component  \nclass ClassA {  \n}  \n  \n@Component  \n@Lazy  \nclass ClassB {  \n    private ClassA classA;  \n  \npublic ClassB(ClassA classA) {  \n    //Logic  \n    System.out.println(\"Some Initialization logic\");  \n    this.classA = classA;  \n    }  \n}  \n  \n@Configuration  \n@ComponentScan  \npublic class LazyInitializationLauncherApplication {  \n  \n    public static void main(String[] args) {  \n        try (var context=  \n                     new AnnotationConfigApplicationContext(LazyInitializationLauncherApplication.class)){  \n        }    }  \n}\n\n```\n\n```\n아무것도 일어나지 않는다.\n```\n- 이제` ClassB Bean`은 시작할 때 초기화 되지 않는다.\n#### `ClassB`를 참조하거나 사용하려 할때만 이 Bean이 로드가 되는게 -> Lazy의 기능\n \n```java\npackage com.in28minutes.learnspringframework.examples.d1.a0;  \n  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.context.annotation.Lazy;  \nimport org.springframework.stereotype.Component;  \n  \n  \n@Component  \nclass ClassA {  \n  \n}  \n  \n@Component  \n@Lazy  \nclass ClassB {  \n    private ClassA classA;  \n  \npublic ClassB(ClassA classA) {  \n    //Logic  \n    System.out.println(\"Some Initialization logic\");  \n    this.classA = classA;  \n    }  \n  \n    public void doSomething() {  \n        System.out.println(\"Do something\");  \n    }  \n  \n}  \n  \n@Configuration  \n@ComponentScan  \npublic class LazyInitializationLauncherApplication {  \n  \n    public static void main(String[] args) {  \n        try (var context=  \n                     new AnnotationConfigApplicationContext(LazyInitializationLauncherApplication.class)){  \n            System.out.println(\"Initialization of context is completed\");  \n            context.getBean(ClassB.class).doSomething();  \n        }  \n    }  \n}\n```\n- Bean을 지연하여 초기화할지 여부를 나타냄.\n-  `@Component`를 사용하는 모든 클래스나 Bean에 어노테이션을 적용한 모든 메서드에서 `Lazy`를 사용할수 있음\n\n#### 즉시 초기화 VS 지연 초기화 중 추천하는 방법은?\n- 항상 즉시 초기화를 추천함. 이유는 Spring 구성에 오류가 있을 경우 즉시 초기화를 사용하면 어플을 실행할 때 오류를 바로 확인 가능.\n- `Lazy`는 권장되지는 않고, 자주 사용되지 않는다. 런타임 오류가 발생하기때문에 오류 발생을 늦게 발견함.\n- ` @Configuration`에 Lazy를 적용할수 있다. Configuration에 있는 Bean들은 다 지연 초기화가 됨.","x":4040,"y":6040,"width":1467,"height":3192},
		{"id":"7e08f56dc38b8676","type":"text","text":"   **MongoDbDataService**","x":3220,"y":-1993,"width":260,"height":60,"color":"4"},
		{"id":"329680799fa47946","type":"text","text":"   **MySQLDataService**","x":3220,"y":-1913,"width":260,"height":60,"color":"4"},
		{"id":"e43e2d6f9ba8d73d","type":"text","text":"**BusinessCalculationService**","x":2940,"y":-2093,"width":260,"height":60,"color":"1"},
		{"id":"0f467f8f2989eb70","type":"text","text":"   **DataService**","x":2940,"y":-1993,"width":260,"height":60,"color":"5"},
		{"id":"10e5cb0c2923a942","type":"text","text":"```java title:\"DataService\"\npackage com.in28minutes.learnspringframework.examples.c1;  \n  \npublic interface DataService {  \n    int[] retrieveData();  \n}\n\n```\n\n```java title:\"BusinessCalculationService\"\npackage com.in28minutes.learnspringframework.examples.c1;  \n  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.stereotype.Component;  \n  \nimport java.util.Arrays;  \n  \n@Component  \n@ComponentScan  \npublic class BusinessCalculationService {  \n  \n    private final DataService dataService;  \n  \n    public BusinessCalculationService(DataService dataService) {  \n        super();  \n        this.dataService = dataService;  \n    }  \n  \n    public int findMax() {  \n        return Arrays.stream(dataService.retrieveData()).max().orElse(0);  \n    }  \n  \n}\n```\n\n```java title:\"MongoDbService\"\npackage com.in28minutes.learnspringframework.examples.c1;  \n  \nimport org.springframework.context.annotation.Primary;  \nimport org.springframework.stereotype.Component;  \n  \n@Component  \n@Primary  \npublic class MongoDbDataService implements DataService {  \n  \n    @Override  \n    public int[] retrieveData() {  \n        return new int[]{11, 22, 33, 44, 55};  \n    }  \n}\n```\n\n```java title:\"MySQLDataService\"\npackage com.in28minutes.learnspringframework.examples.c1;  \n  \nimport org.springframework.context.annotation.Primary;  \nimport org.springframework.stereotype.Component;  \n  \n@Component  \n@Primary  \npublic class MongoDbDataService implements DataService {  \n  \n    @Override  \n    public int[] retrieveData() {  \n        return new int[]{11, 22, 33, 44, 55};  \n    }  \n}\n```\n\n```java title=\"RealWorldSpringContextLancherApplication\"\npackage com.in28minutes.learnspringframework.examples.c1;  \n  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.context.annotation.Configuration;  \n  \nimport java.util.Arrays;  \n  \n  \n@Configuration  \n@ComponentScan  \npublic class RealWorldSpringContextLauncherApplication {  \n  \n    public static void main(String[] args) {  \n        try (var context=  \n                     new AnnotationConfigApplicationContext(RealWorldSpringContextLauncherApplication.class)){  \n            Arrays.stream(context.getBeanDefinitionNames())  \n                    .forEach(System.out::println);  \n            System.out.println(context.getBean(BusinessCalculationService.class).findMax());  \n        }  \n    }  \n}\n```\n\n> [!NOTE-] \n> 일반적으로 실제 애플리케이션을 다루는 경우, 이런 방식으로 주어지게 되고, 데이터 서비스를 호출하는 비즈니스 서비스를 갖게 됩니다. 비즈니스 로직에만 집중할수 있습니다. 데이터 서비스 및 비즈니스 서비스의 인스턴스를 생성하는 방법, 의존성을 연결(Auto-wired)하는 방법에는 그다지 주목할 필요없습니다. 모든것을 Spring이 하기 때문에. ","x":2940,"y":-1780,"width":1240,"height":2160},
		{"id":"0efa005110a93b14","type":"text","text":" ### Jakarta Contexts & Dependency Injection(CDI)\n - Java EE의 핵심 기술 -> 현재는 Jakarta Contexts and Dependency Injection으로 불림\n- CDI는 인터페이스이고 구현이 없고 Spring Framework 구현함\n##### 구성요소\n- `Inject`, `Named`, `Qualifier` , `Scope`, `Singleton`\n\n``` xml\n<dependency>  \n    <groupId>jakarta.inject</groupId>  \n    <artifactId>jakarta.inject-api</artifactId>  \n    <version>2.0.1</version>  \n</dependency>\n```\n\n\n```java\npackage com.in28minutes.learnspringframework.examples.g1;  \n  \nimport org.springframework.beans.factory.annotation.Autowired;  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.context.annotation.Configuration;  \nimport org.springframework.stereotype.Component;  \n  \nimport java.util.Arrays;  \n  \n@Component  \nclass BusinessService {  \n   private DataService dataService;  \n  \n  \n    public DataService getDataService() {  \n       System.out.println(\"Setter Injection\");  \n        return dataService;  \n    }  \n    @Autowired  \n    public void setDataService(DataService dataService) {  \n        this.dataService = dataService;  \n    }  \n}  \n  \n@Component  \nclass DataService {  \n}  \n  \n@Configuration  \n@ComponentScan  \npublic class CdiContextLauncherApplication {  \n  \n    public static void main(String[] args) {  \n        try (var context=  \n                     new AnnotationConfigApplicationContext(CdiContextLauncherApplication.class)){  \n            Arrays.stream(context.getBeanDefinitionNames())  \n                    .forEach(System.out::println);  \n            System.out.println(context.getBean(BusinessService.class).getDataService());  \n        }  \n    }  \n}\n\n```\n```\ncdiContextLauncherApplication\nbusinessService\ndataService\nSetter Injection\ncom.in28minutes.learnspringframework.examples.g1.DataService@29e495ff\n```\n\n```java\npackage com.in28minutes.learnspringframework.examples.g1;  \n  \nimport jakarta.inject.Inject;  \nimport jakarta.inject.Named;  \nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;  \nimport org.springframework.context.annotation.ComponentScan;  \nimport org.springframework.context.annotation.Configuration;  \n  \nimport java.util.Arrays;  \n  \n//@Component  \n@Named  \nclass BusinessService {  \n   private DataService dataService;  \n  \n  \n    public DataService getDataService() {  \n        return dataService;  \n    }  \n  \n//    @Autowired  \n    @Inject  \n    public void setDataService(DataService dataService) {  \n        System.out.println(\"Setter Injection\");  \n        this.dataService = dataService;  \n    }  \n}  \n  \n//@Component  \n@Named  \nclass DataService {  \n}  \n  \n@Configuration  \n@ComponentScan  \npublic class CdiContextLauncherApplication {  \n  \n    public static void main(String[] args) {  \n        try (var context=  \n                     new AnnotationConfigApplicationContext(CdiContextLauncherApplication.class)){  \n            Arrays.stream(context.getBeanDefinitionNames())  \n                    .forEach(System.out::println);  \n            System.out.println(context.getBean(BusinessService.class).getDataService());  \n        }  \n    }  \n}\n\n```\n```\ncdiContextLauncherApplication\nbusinessService\ndataService\ncom.in28minutes.learnspringframework.examples.g1.DataService@5ace1ed4\n\n```\n\n#### `@Inject=`@Autowired` ,` `@Named` = `@Component`역할 같다는걸 알수 있다.\n- Spring Framework에서는 CDI 지원됩니다.\n","x":5200,"y":1840,"width":919,"height":2760}
	],
	"edges":[
		{"id":"b46f2d7757e372a1","fromNode":"373118e29d9ff113","fromSide":"right","toNode":"8da2f39b6d9f7b3e","toSide":"left"},
		{"id":"9e6b683c8c7aa856","fromNode":"5486e2d5aacb9370","fromSide":"right","toNode":"1f0c16407231e61b","toSide":"left"},
		{"id":"037fc9f620896060","fromNode":"5486e2d5aacb9370","fromSide":"right","toNode":"919325a29584adda","toSide":"left"},
		{"id":"1018b902996a83f8","fromNode":"b7534024c246fc0d","fromSide":"right","toNode":"a6ef766c4a1acf4e","toSide":"left"},
		{"id":"790eb362f4c93169","fromNode":"b7534024c246fc0d","fromSide":"right","toNode":"0753611c70d43d75","toSide":"left"},
		{"id":"8aae856b0f75413d","fromNode":"b7534024c246fc0d","fromSide":"right","toNode":"cc15d7924418e992","toSide":"left"},
		{"id":"1d38ff1ed90425b4","fromNode":"bdde4b5441baaa04","fromSide":"right","toNode":"b7534024c246fc0d","toSide":"left"},
		{"id":"ca852f5998501bf2","fromNode":"4a0a8086f35e68a8","fromSide":"right","toNode":"d4c707bf7cb9ba88","toSide":"left"},
		{"id":"8a16d29751f5421a","fromNode":"7c4a531516e68f66","fromSide":"bottom","toNode":"6ee8c014bb583c90","toSide":"top","color":"1"},
		{"id":"82637e9d7e642f09","fromNode":"e43e2d6f9ba8d73d","fromSide":"bottom","toNode":"0f467f8f2989eb70","toSide":"top"},
		{"id":"3fdc4c15a94f8723","fromNode":"0f467f8f2989eb70","fromSide":"right","toNode":"7e08f56dc38b8676","toSide":"left"},
		{"id":"09e24888701b07c6","fromNode":"0f467f8f2989eb70","fromSide":"bottom","toNode":"329680799fa47946","toSide":"left"}
	]
}